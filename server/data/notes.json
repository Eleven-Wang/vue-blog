[{"title":"js笔记","type":"js","content":"笔记内容","date":"Fri Nov 20 2020","id":3},{"title":"vue笔记","type":"vuejs","content":"笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容笔记内容","date":"Fri Nov 20 2020","id":4},{"title":"12","type":"html","date":"Fri Nov 20 2020","id":5},{"title":"2","type":"html","content":"<p>2sadf</p>","date":"Fri Nov 20 2020","id":6},{"title":"test","type":"html","content":"<p>better-scroll 是一款重点解决移动端（现已支持 PC 端）各种滚动场景需求的插件。它的核心是借鉴的 iscroll 的实现，它的 API 设计基本兼容 iscroll，在 iscroll 的基础上又扩展了一些特征以及做了一些性能优化。 better-scroll 是基于原生 JS 实现的，不依赖任何框架。 手册地址：<a href=\"http://ustbhuangyi.github.io/better-scroll/doc/zh-hans/\">http://ustbhuangyi.github.io/better-scroll/doc/zh-hans/</a></p><p><br></p><p>安装：</p><ul><li>npm</li></ul><p>npm install better-scroll --save</p><ul><li>引入：</li><ul><li><a href=\"https://webpack.js.org/\">webpack</a>&nbsp;等构建工具都支持从 node_modules 里引入代码：</li></ul></ul><p>import BScroll from 'better-scroll'</p><ul><li>ES5语法：</li></ul><p>var BScroll = require('better-scroll')</p><ul><li>script加载</li><ul><li>https://unpkg.com/better-scroll/dist/bscroll.min.js</li></ul></ul><p>使用说明：</p><p>new BScroll(wrapper，{ 配置信息 })</p><p><br></p><p><br></p><p>better-scroll 只处理容器（wrapper）的第一个子元素（content）的滚动，其它的元素都会被忽略</p><p><br></p><p><br></p><p>常用事件</p><p>scroll（监听的时候注意配置probeType(1,2,3</p><p>参数：{Object} {x, y} 滚动的实时坐标</p>","date":"Fri Nov 20 2020","id":7},{"title":"新的一篇","type":"html","content":"<p>新的一篇内容是什么呢？<span style=\"font-size: 16px;\">前端：</span></p><p>后台</p><p><br></p><p>博客后台编辑器插件</p><p><br></p><p>博客后台编辑器插件-完善</p><p><br></p><p>后台填写内容添加验证（必填，语法问题前端验证，不传输到后台处理</p><p>前台</p><p><br></p><p>前台用vuex管理</p><p><br></p><p>detail页面样式重写</p><p><br></p><p>实现吸顶效果</p><p><br></p><p>后端：</p><p><br></p><p>后台数据传输用mysql数据库</p><p><br></p><p>后台使用koa使用MVC模式</p><p><br></p><p>后台验证完善</p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p>实现进程</p><p>11.20</p><p>detail页面样式重写</p><p>博客后台编辑器插件</p><p>吸顶效果</p><p>吸顶的实现：</p><ul><ol><li>position:sticky</li><li>getBoundingClientRect()  抖动问题</li></ol></ul><p><br></p><p>？？ 改代码保存，页面不刷新时，$refs对象丢失</p><p>11.19</p><p>实现前后台数据交互</p><p>添加数据</p><p>删除数据</p><p>登录页面+逻辑实现</p><p>验证身份</p><p>11.18之前</p><p>博客简单样式</p><p>后台简单样式</p><p>vue-cli构建整个项目</p><p>实现博客简单逻辑</p><p><br></p><p><br></p><p><br></p><p><br></p><p>技术栈</p><p>vue-cli</p><p><br></p><p>文件</p><p>app</p><p>...</p><p>src</p><p>app.vue</p><p>main.js</p><p>...</p><p>router</p><p>components</p><p>HeaderTop</p><p>Footer</p><p>views</p><p>Index</p><p>Login</p><p>Admin</p><p><br></p><p>server</p><p>app.js</p><p>...</p><p>data</p><p>notes.json</p><p>users.json</p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p>","date":"Fri Nov 20 2020","id":8},{"title":"1222","type":"html","content":"<p>32423dfadfsadf</p>","date":"Fri Nov 20 2020","id":9},{"title":"232","type":"html","content":"<p>2222</p>","date":"Fri Nov 20 2020","id":10},{"title":"343","type":"html","content":"<p>34</p>","date":"Fri Nov 20 2020","id":11},{"title":"33","type":"html","content":"<p>33</p>","date":"Fri Nov 20 2020","id":12},{"title":"33","type":"html","content":"<p>33</p>","date":"Fri Nov 20 2020","id":13},{"title":"33","type":"html","content":"<p>3333</p>","date":"Fri Nov 20 2020","id":14},{"title":"12","type":"html","content":"<p>111</p>","date":"Sat Nov 21 2020","id":15},{"title":"2323","type":"html","content":"<p>2323</p>","date":"Sat Nov 21 2020","id":16},{"title":"hyhhjj","type":"css","content":"<p>bhjhkjk</p>","date":"Mon Dec 07 2020","id":17},{"title":"vue-blog","type":"html","content":"<p>主流的数据传输格式：json, xml</p><p><br></p><p>Ajax:Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）</p><p>AJAX 是与服务器交换数据并更新部分网页的艺术，在不重新加载整个页面的情况下。</p><p>依赖XMLHttpRequest对象</p><p><br></p><p>XMLHttpRequest对象的使用</p><p>//前端的设置（在js里写\ndocument.querySelector(\".inputStyle\").onblur = function(){\n    let xhr = new XMLHttpRequest();  //触发事件时新建一个对象\n    xhr.open(\"get\",\"/checkUserName?username=${this.value},true);//第二个参数是对象向后端发起的请求，第三个参数设置异步(true)同步(false)\n    xhr.onload = function(){\n        console.log(xhr.responseText); //接收返还值\n    });\n    xhr.send();\n}</p><p><br></p><p>两种方式</p><p>get 直接路由上带信息传递，后端路由上读取信息（传输数据有限制</p><p>通过parmas传参</p><p>通过url传参（querystring</p><p>post 也可以路由上带数据，一般把要传输的信息放在xhr.send(data)里（传输数据没有限制</p><p>前端向后端发送数据必须设置http正文头格式，</p><ul><li>xhr.setRequestHeader(\"content-type\", \"application/x-www-form-urlencoded \")  默认编码</li><li>xhr.setRequestHeader(\"content-type\", \"multipart/form-data\") 二进制编码（传输文件</li><li>xhr.setRequestHeader(\"content-type\", \"application/json\") json编码，注意传输的数据是否转为json格式（JSON.stringfy()）</li></ul><p>获取头部信息</p><p>getAllResponseHeaders 或 getResponseHeader</p><p><br></p><p>后端向前端传输数据，后端设置传输数据的格式：ctx.set(\"content-type\",\"    \") / 前端强制转换接受到的数据格式：xhr.overrideMimeType(\"    \")(前端重写response里的content-type )</p><p><br></p><p>xhr.onload事件表示传输完成返回完成后进行的操作(xhr.readyState = 4, xhr.status = 200</p><p>也可以用xhr.onreadystatechange监控状态变化（更复杂，建议使用onload）</p><table><colgroup><col><col></colgroup><tbody><tr><td><p>readyState</p></td><td><p>存有 XMLHttpRequest 的状态。从 0 到 4 发生变化。</p><p>0: 请求未初始化</p><p>1: 服务器连接已建立</p><p>2: 请求已接收</p><p>3: 请求处理中</p><p>4: 请求已完成，且响应已就绪</p></td></tr><tr><td><p>status</p></td><td><p>200: \"OK\"</p><p>404: 未找到页面</p></td></tr></tbody></table><p><br></p><p>返还数据类型</p><ul><li>json数据  xhr.responseText(返还文本)</li><li>xml数据  xhr.responseXML</li><li>原始数据 xhr.response</li></ul><p><br></p><p>同步及异步ajax</p><ul><li>true 异步</li><li>false 同步</li></ul><p><br></p><p>利用formData对象实现文件上传（用formData对象不用设置头文件</p><p>创建FormData对象</p><p>let file = document.querySelector(\".myfile\").files[0];\n// console.log(files);\nlet form = new FormData();\nform.append(\"img\",file);\nform.append(\"name\",\"张三\");\nlet xhr = new XMLHttpRequest();\nxhr.open(\"post\",\"/upload\",true);\nxhr.onload = function(){\n    console.log(xhr.responseText);\n}\nxhr.send(form);</p><p>监控上传进度</p><p>upload事件</p><ul><li>onloadstart 上传开始</li><li>onprogress 数据传输进行中</li><ul><li>evt.total 需要传输的总大小</li><li>evt.loaded 当前上传的文件大小</li></ul><li>onabort 上传操作终止</li><li>onerror 上传失败</li><li>onload 上传成功</li><li>onloadend 上传完成（无论成功与否）</li></ul><p><br></p><p>ajax和form表单都是提交数据，区别：</p><p>form表单必须刷新</p><p>ajax可以实现无刷更新，或者局部刷新</p><p><br></p><p><br></p><p>fileReader()</p><p>var fr = new FileReader();\nfr.readAsDataURL(file);\nfr.onload = function (event) {\n    var data= event.target.result; //此处获得的data是base64格式的数据\n&nbsp; &nbsp; img.src = data;\n}</p><p>此处的data可以实现图片上传前的本地预览，也可以用来发送base64数据给后端然后返回该数据块对应的地址。</p><p>（正常input标签内的files文件，可以传递到后端，但是在前端无法读取文件地址信息，无法本地预览）</p><p>如果需要上传前本地预览，就借助fileReader对象</p><p><br></p><p>Blob对象</p><p><br></p><p>前端传输文件，后端用ctx.request.files获取传输的文件</p><p><br></p><p><br></p><p>await 在forEach里不起作用</p><p><br></p><p>Ajax封装</p><p>function&nbsp;ajax(options){\n&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;opt&nbsp;=&nbsp;Object.assign({  //合并参数\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;method:&nbsp;\"get\",\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;url:&nbsp;\"/\",\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;headers:&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\"content-type\":&nbsp;\"application/x-www-form-urlencoded\"\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;},\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;data:&nbsp;{},\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jsonp:&nbsp;\"cb\",\n        success:&nbsp;function(){}\n&nbsp;&nbsp;&nbsp;&nbsp;},options);\n\n&nbsp;&nbsp;&nbsp;&nbsp;if(opt.dataType&nbsp;===&nbsp;\"jsonp\"){\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;o&nbsp;=&nbsp;document.createElement(\"script\");\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;window[\"callback\"]&nbsp;=&nbsp;opt.success;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;o.src&nbsp;=&nbsp;opt.url&nbsp;+&nbsp;\"?\"&nbsp;+&nbsp;o2s(opt.data)&nbsp;+&nbsp;\"&amp;\"&nbsp;+&nbsp;opt.jsonp&nbsp;+&nbsp;\"=callback\";\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;document.querySelector(\"head\").appendChild(o);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;false;\n&nbsp;&nbsp;&nbsp;&nbsp;}\n\n&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;xhr&nbsp;=&nbsp;new&nbsp;XMLHttpRequest();\n&nbsp;&nbsp;&nbsp;&nbsp;if(opt.method.toLowerCase()&nbsp;===&nbsp;\"get\"){\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;opt.url&nbsp;+=&nbsp;\"?\"&nbsp;+&nbsp;o2s(opt.data);\n&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;xhr.open(opt.method,&nbsp;opt.url,&nbsp;true);\n&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(const&nbsp;i&nbsp;in&nbsp;opt.headers)&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xhr.setRequestHeader(i,&nbsp;opt.headers[i]);\n&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;xhr.onload&nbsp;=&nbsp;function(){\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;res&nbsp;=&nbsp;xhr.responseText;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log(typeof&nbsp;res);\n&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;if(opt.method.toLowerCase()&nbsp;===&nbsp;\"get\"){\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xhr.send();\n&nbsp;&nbsp;&nbsp;&nbsp;}else{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log(typeof&nbsp;JSON.stringify(opt.data));\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xhr.send(JSON.stringify(opt.data));\n&nbsp;&nbsp;&nbsp;&nbsp;}\n\n&nbsp;&nbsp;&nbsp;&nbsp;function&nbsp;o2s(data){\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;dataArr&nbsp;=&nbsp;[];\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(const&nbsp;i&nbsp;in&nbsp;data)&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;str&nbsp;=&nbsp;i&nbsp;+&nbsp;\"=\"&nbsp;+&nbsp;data[i];\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dataArr.push(str);&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;dataArr.join(\"&amp;\");\n&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;\n}</p><p><br></p><p><br></p><p><br></p><p>同源 与 跨域(跨域是浏览器行为</p><p>协议&nbsp;域名（ip）&nbsp;端口号&nbsp;一样&nbsp;&nbsp;同源&nbsp;&nbsp;；否则&nbsp;跨域&nbsp;；（浏览器为了安全问题）；</p><p>https://www.kaikeba.com:443</p><p>http://www.baidu.com:80</p><p><br></p><p>不涉及跨域的方式：img iframe script</p><p><br></p><p>跨域的方式：</p><p>jsonp</p><p>利用不涉及跨域的标签来引入跨域的</p><p>tips:</p><p>只支持get方式</p><p>注意，如果前端给第二个服务器带的参数有函数，第二个服务器返还的函数在后端并不执行，带参数返还给前端</p><p>？？（有必要前端传输带函数到后端么？？直接获取后端数据，前端处理就行？）！！有必要</p><p>约定好的，因为可能请求别的网站的数据，所以需要用约定俗成的规则来写，才能获取到</p><p>用回调函数是为了把返还的数据带到前端来，回调函数的名字需要和目标网站的一致</p><p><br></p><p>jsonp的ajax封装</p><p><br></p><p>(功能实现：</p><p>下拉加载数据（通过滚动条的位置控制提前加载下一部分的数据)</p><p><br></p><p>cors跨域设置&nbsp;（服务端）</p><ul><li>('Access-Control-Allow-Origin', '*')  //这个表示任意域名都可以访问，默认不能携带cookie了。(必须字段)</li></ul><p>（正常情况，访问浏览器页面的时候，客户端的cookie会被带到服务端）</p><p>res.header('Access-Control-Allow-Origin', 'http://www.baidu.com'); //这样写，只有www.baidu.com 可以访问跨域访问。</p><p>被跨域访问的服务器可以设置哪些域名可以跨域访问它</p><p>ctx.set('Access-Control-Allow-Origin', 'http://www.baidu.com')  //只有www.baidu.com 可以访问跨域访问</p><ul><li>Access-Control-Allow-Credentials:布尔值  true允许携带cookie；(可选字段)</li></ul><p>上一个参数不能设置成*，任意域名都可以访问，这样写不能携带cookie</p><p>跨域请求默认不带cookie; 同源请求默认带cookie</p><p>cookie设置也要通过ajax</p><p>//客户端，服务端都需要设置\n\n//客户端设置允许携带用户凭证\nxhr.withCredentials = true;\n\n//服务端设置允许携带自己cookie\nctx.set(\"Access-Control-Allow-Credentials\",true);</p><p><br></p><ul><li>Access-Control-Allow-Headers : 设置允许请求的头部信息</li></ul><p>res.header('Access-Control-Allow-Headers', 'Content-Type, Content-Length, Authorization, Accept, X-Requested-With , yourHeaderFeild');</p><p><br></p><p><br></p><ul><li>Access-Control-Allow-Methods ：设置允许请求的方法；</li></ul><p>res.header('Access-Control-Allow-Methods', 'PUT, POST, GET, DELETE, OPTIONS');//设置方法</p><p><br></p><ul><li>Access-Control-Expose-Headers 允许客户端获取的头部key；</li></ul><p>CORS请求时，XMLHttpRequest对象的getAllResponseHeader()方法只能拿到6个基本字段：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma。如果想拿到其他字段，就必须在服务端的Access-Control-Expose-Headers里面指定。</p><p><br></p><ul><li>预检请求</li><ul><li>简单的请求直接发送</li></ul></ul><ul><ul><li>GET</li><li>HEAD</li><li>POST</li><li>content-type(如果这个不是下面三种形式，也会预检请求)</li><ul><li>text/plain</li><li>multipart/form-data</li><li>application/x-www-form-urlencoded</li></ul></ul><li>预检请求（浏览器为了安全提前检测一次</li></ul><p>第一次发送的request method是options</p><ul><li>PUT</li><li>DELETE</li><li>CONNECT</li><li>OPTIONS</li><li>TRACE</li><li>PATCH</li></ul><p><br></p><ul><li>Access-Control-Max-Age用来指定本次预检请求的有效期，单位为秒，，在此期间不用发出另一条预检请求。(原本会预定义一个时间内缓存，缓存事件内不会发出预检请求</li></ul><p>ctx.set(\"Access-Control-Max-Age\", 3000);</p><p><br></p><p><br></p><p>服务器代理（最常见</p><p>利用服务端跨域，与浏览器无关以解决跨域问题（跨域是浏览器规范，通过同服务器请求数据，不通过浏览器请求，也能解决浏览器限制）</p><ul><li>利用http模块（原生模块）</li><li>利用koa-server-http-proxy中间件实现代理</li></ul><p>app.use(koaServerHttpProxy('/api', { target: 'http://localhost:4000', pathRewrite: { '^/api': '' } }))</p><p><br></p><p><br></p><p>举例：通过koa-server-http-proxy在koa中实现新闻后台添加功能</p><p>客户端的服务器转发到服务端的服务器，服务端的data数据直接传输到客户端的页面，在页面的Js里生成页面元素。</p><p>？？不需要在客户端的服务器渲染页面(模板引擎用不到？？ 是的，解决方式不同，服务器代理是把数据直接返回到客户端前端，进行处理</p><p><br></p><p><br></p><p>http协议</p><p>传输协议 http</p><p>请求报文</p><p>响应报文</p><p><br></p><p>Fetch</p><p>ajax的一种变式（只支持新的浏览器，如果需要兼容性，用xmlhttprequest写</p><p>写法</p><p>fetch(\"/test\").then(res=&gt;{\n    //let result = res.clone(res);  //把数据克隆出来，再操作数据的话不会更改到原始数据\n    //return result.json();\n    return res.json();  //res.text()就是内容的文本形式；res.json()得到的是json数据，是对象\n}).then(res=&gt;{\n    console.log(res);  // 得到数据\n}).catch(err=&gt;{\n    console.log(err);\n})</p><p><br></p><ul><li>第一个参数是请求的url</li><li>第二个参数 opotions对象 常用配置</li></ul><ul><li>method: 请求使用的方法，如&nbsp;GET、``POST。  默认是get</li><li>headers: 请求的头信息，形式为&nbsp;<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Headers\">Headers</a>&nbsp;的对象或包含&nbsp;<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/ByteString\">ByteString</a>&nbsp;值的对象字面量。</li><li>body: 请求的 body 信息：可能是一个&nbsp;<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Blob\">Blob</a>、<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/BufferSource\">BufferSource</a>、<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/FormData\">FormData</a>、<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/URLSearchParams\">URLSearchParams</a>&nbsp;或者&nbsp;<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/USVString\">USVString</a>&nbsp;对象。注意 GET 或 HEAD 方法的请求不能包含 body 信息。</li><li>mode: 请求的模式，如&nbsp;cors、&nbsp;no-cors&nbsp;或者&nbsp;same-origin。</li></ul><ul><li>same-origin表示必须同源，绝对禁止跨域，这个是老版本浏览器默认的安全策略。</li><li>no-cors这个就很特殊了，字面意思是禁止以CORS的形式跨域，其实它的效果是，对外域的请求可以发送，外域服务器无论设不设Access-Control-Allow-Origin: *都会接收请求并处理请求，但是浏览器不接收响应，即使外域返回了内容，浏览器也当做没接到</li></ul><p>headers对象</p><p>你可以通过&nbsp;<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Headers/Headers\">Headers()</a>&nbsp;构造函数来创建一个你自己的 headers 对象。</p><p>var myHeaders = new Headers();\n\nmyHeaders.append(\"Content-Type\", \"text/plain\");\nmyHeaders.append(\"Content-Length\", content.length.toString());\nmyHeaders.append(\"X-Custom-Header\", \"ProcessThisImmediately\")\n\n//作用同上\nmyHeaders = new Headers({\n  \"Content-Type\": \"text/plain\",\n  \"Content-Length\": content.length.toString(),\n  \"X-Custom-Header\": \"ProcessThisImmediately\",\n});</p><p>缺点</p><ul><li>兼容性差</li><li>fetch不能监控文件进度</li></ul><p><br></p><p>axios库</p><p>ajax库，底层库，需要引入</p><p>是一个基于promise的HTTP库，可以用在浏览器和node.js中</p><p>使用方式</p><ol><li>安装： $ npm install axios</li><li>下载文件后引入”axios.js“</li></ol><p>写法</p><p>//get方式\naxios({\n    url: \"/axios\",\n    method: \"get\",\n    params:{           // get方式下在域名后带数据的内容\n        name: \"axios\",\n        age:20\n    }\n}).then(res=&gt;{\n    console.log(res);\n})\n//post方式一\naxios({                  //所有数据放在一个对象里，对axios对象进行设置\n    url: \"/axios\",\n    method: \"post\",\n    data:{           // post方式下带的数据\n        name: \"axiosPost\",\n        age:20\n    }，\n    headers:{\n        ...\n    },\n    transformResponse:[function(data){      //拦截回复数据，可以把数据在这里进行再处理之后传输\n        console.log(\"res\":data),\n        return data;\n    }],\n    transformResquest:[function(data){      //拦截请求数据，可以把数据在这里进行再处理之后传输\n        console.log(\"req\":data),\n        return data;\n    }]\n}).then(res=&gt;{\n    console.log(res);\n})\n//post方式二\naxios.post(\"/axios\",{        //第一个参数放url，第二个参数放传输数据，第三个参数放headers配置          \n    name: \"axiosPost\",\n    age:20\n},{\n    headers:{\n        ...\n}).then(res=&gt;{\n    console.log(res);\n})</p><p><br></p><p>拦截器</p><p>如果要对全局的进行拦截，用这个，如果对单个数据进行拦截，用上面的方法</p><p>可以做权限认证 凭证验证</p><p>axios.interceptors.request.use(function (config){\n    console.log(\"request interceptors\");         //在所有axios请求之前都会进行这一步\n    return config;\n})\naxios.interceptors.response.use(function (config){\n    console.log(\"response interceptors\");        //在所有axios回应之前都会进行这一步\n    return config;\n})</p><p><br></p><p>针对url的处理</p><p>工具类util --&gt; 单例模式</p><p>let util =  {}</p><p>get处理url</p><p>buildURL函数</p><p>let util = {\n    buildURL(params, url){\n        if(typeof params !== \"undefined\"){\n            \n        }\n    }\n}</p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p>","date":"Thu Dec 24 2020","id":18}]